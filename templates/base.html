<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Reddit Reader{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest/dist/hls.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo-group">
                <a href="{{ url_for('index') }}" class="logo-icon" title="Go to r/all">üìñ</a>
                {% if is_subreddit_page %}
                <a href="javascript:window.scrollTo({top:0,behavior:'smooth'});setTimeout(()=>location.reload(),300);" class="logo-text" title="Reload">Reddit Reader</a>
                {% else %}
                <a href="{{ url_for('index') }}" class="logo-text" title="Go to r/all">Reddit Reader</a>
                {% endif %}
            </div>
            <form action="{{ url_for('search') }}" method="get" class="search-form">
                <input type="text" 
                       name="q" 
                       class="search-input" 
                       placeholder="Search subreddit..."
                       autocomplete="off">
            </form>
            <div class="header-auth">
                {% if current_user.is_authenticated %}
                    <a href="{{ url_for('settings') }}" class="btn btn-small btn-icon" title="Settings">‚öôÔ∏è</a>
                    <span class="header-user">üë§ {{ current_user.username }}</span>
                    <a href="{{ url_for('logout') }}" class="btn btn-small">Logout</a>
                {% else %}
                    <a href="{{ url_for('login') }}" class="btn btn-small">Login</a>
                    <a href="{{ url_for('register') }}" class="btn btn-small btn-primary">Register</a>
                {% endif %}
            </div>
        </div>
    </header>
    <div class="header-spacer"></div>

    <main class="container">
        {% block content %}{% endblock %}
    </main>

    <script>
        // Header hide/show on scroll and mouse
        (function() {
            const header = document.querySelector('.header');
            let lastScrollY = window.scrollY;
            let ticking = false;
            
            function updateHeader() {
                const currentScrollY = window.scrollY;
                
                // Show header at top of page or when scrolling up
                if (currentScrollY <= 50 || currentScrollY < lastScrollY) {
                    header.classList.remove('header-hidden');
                } 
                // Hide when scrolling down
                else if (currentScrollY > lastScrollY) {
                    header.classList.add('header-hidden');
                }
                
                lastScrollY = currentScrollY;
                ticking = false;
            }
            
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    requestAnimationFrame(updateHeader);
                    ticking = true;
                }
            });
            
            // Show header when mouse moves to top of viewport
            document.addEventListener('mousemove', (e) => {
                if (e.clientY <= 50) {
                    header.classList.remove('header-hidden');
                }
            });
        })();

        document.addEventListener('click', async (event) => {
            const toggle = event.target.closest('.comment-toggle');
            if (!toggle) return;

            const container = toggle.closest('.post-top-comments');
            const list = container.querySelector('.comment-list');
            const subreddit = toggle.dataset.subreddit;
            const postId = toggle.dataset.postId;
            const limit = toggle.dataset.limit || 3;

            const isLoaded = list.dataset.loaded === 'true';
            const isHidden = list.hasAttribute('hidden');

            if (!isLoaded) {
                toggle.textContent = 'Loading...';
                try {
                    const response = await fetch(`/api/comments?subreddit=${encodeURIComponent(subreddit)}&post_id=${encodeURIComponent(postId)}&limit=${encodeURIComponent(limit)}`);
                    const data = await response.json();
                    list.innerHTML = '';

                    if (data.comments && data.comments.length) {
                        const showAuthor = list.dataset.showAuthor !== 'false';
                        data.comments.forEach((comment) => {
                            list.appendChild(createCommentElement(comment, 0, showAuthor));
                        });
                    } else {
                        const empty = document.createElement('div');
                        empty.className = 'text-secondary';
                        empty.style.fontSize = '13px';
                        empty.textContent = 'No comments found.';
                        list.appendChild(empty);
                    }

                    list.dataset.loaded = 'true';
                    list.removeAttribute('hidden');
                    toggle.textContent = 'Hide comments';
                } catch (err) {
                    toggle.textContent = 'Load comments';
                }
            } else {
                if (isHidden) {
                    list.removeAttribute('hidden');
                    toggle.textContent = 'Hide comments';
                } else {
                    list.setAttribute('hidden', '');
                    toggle.textContent = 'Load comments';
                }
            }
        });

        // Media download button (left click)
        document.addEventListener('click', (event) => {
            const btn = event.target.closest('.media-download-btn');
            if (btn) {
                const url = btn.dataset.url;
                const filename = getFilenameFromUrl(url);
                triggerDownload(url, filename);
                return;
            }

            // Close menu on any other click
            closeDownloadMenu();
        });

        // Media download button (right click opens menu)
        document.addEventListener('contextmenu', (event) => {
            const btn = event.target.closest('.media-download-btn');
            if (!btn) return;

            event.preventDefault();
            openDownloadMenu(event.clientX, event.clientY, btn.dataset.url);
        });

        function openDownloadMenu(x, y, url) {
            closeDownloadMenu();

            const menu = document.createElement('div');
            menu.className = 'media-download-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;

            const downloadBtn = document.createElement('button');
            downloadBtn.textContent = 'Download';
            downloadBtn.addEventListener('click', () => {
                const filename = getFilenameFromUrl(url);
                triggerDownload(url, filename);
                closeDownloadMenu();
            });

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Download as...';
            renameBtn.addEventListener('click', async () => {
                const defaultName = getFilenameFromUrl(url);
                const customName = prompt('Save file as:', defaultName);
                if (customName) {
                    await triggerDownload(url, customName);
                }
                closeDownloadMenu();
            });

            menu.appendChild(downloadBtn);
            menu.appendChild(renameBtn);
            document.body.appendChild(menu);
        }

        function closeDownloadMenu() {
            document.querySelectorAll('.media-download-menu').forEach(menu => menu.remove());
        }

        function getFilenameFromUrl(url) {
            try {
                const parsed = new URL(url);
                const pathname = parsed.pathname.split('/').pop() || 'media';
                return decodeURIComponent(pathname.split('?')[0]);
            } catch {
                return 'media';
            }
        }

        async function triggerDownload(url, filename) {
            try {
                const response = await fetch(url, { mode: 'cors' });
                const blob = await response.blob();
                const objectUrl = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = objectUrl;
                link.download = filename || 'media';
                document.body.appendChild(link);
                link.click();
                link.remove();
                URL.revokeObjectURL(objectUrl);
            } catch {
                window.open(url, '_blank');
            }
        }

        function createCommentElement(comment, depth = 0, showAuthor = true) {
            const item = document.createElement('div');
            item.className = depth > 0 ? 'comment compact comment-reply' : 'comment compact';
            item.dataset.depth = depth;

            // Expand button container
            const expandDiv = document.createElement('div');
            expandDiv.className = 'comment-expand';
            
            if (comment.replies && comment.replies.length > 0) {
                const expandBtn = document.createElement('button');
                expandBtn.className = 'comment-expand-btn';
                expandBtn.textContent = '+';
                expandDiv.appendChild(expandBtn);
            }
            
            item.appendChild(expandDiv);

            // Content container
            const contentDiv = document.createElement('div');
            contentDiv.className = 'comment-content';

            const score = document.createElement('span');
            score.className = 'comment-score';
            score.textContent = `‚¨ÜÔ∏è ${comment.score.toLocaleString()}`;

            const meta = document.createElement('div');
            meta.className = 'comment-meta-right';
            if (showAuthor) {
                const author = document.createElement('span');
                author.className = 'comment-author';
                author.textContent = `u/${comment.author}`;
                meta.appendChild(author);
            }
            meta.appendChild(score);

            const body = document.createElement('div');
            body.className = 'comment-body';
            body.textContent = comment.body;

            contentDiv.appendChild(meta);
            contentDiv.appendChild(body);

            // Add replies if present
            if (comment.replies && comment.replies.length > 0) {
                const repliesDiv = document.createElement('div');
                repliesDiv.className = 'comment-replies';
                repliesDiv.setAttribute('hidden', '');
                
                comment.replies.forEach(reply => {
                    repliesDiv.appendChild(createCommentElement(reply, depth + 1, showAuthor));
                });
                
                contentDiv.appendChild(repliesDiv);
            }

            item.appendChild(contentDiv);
            return item;
        }

        // Gallery navigation
        document.addEventListener('click', (event) => {
            const navLeft = event.target.closest('.gallery-nav-left');
            const navRight = event.target.closest('.gallery-nav-right');
            
            if (navLeft) {
                const scroll = navLeft.parentElement.querySelector('.gallery-scroll');
                const images = Array.from(scroll.children);
                const scrollLeft = scroll.scrollLeft;
                
                let targetImage = images[0];
                for (let i = images.length - 1; i >= 0; i--) {
                    if (images[i].offsetLeft < scrollLeft - 10) {
                        targetImage = images[i];
                        break;
                    }
                }
                
                targetImage.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                return;
            }
            
            if (navRight) {
                const scroll = navRight.parentElement.querySelector('.gallery-scroll');
                const images = Array.from(scroll.children);
                const scrollLeft = scroll.scrollLeft;
                
                let targetImage = images[images.length - 1];
                for (let i = 0; i < images.length; i++) {
                    if (images[i].offsetLeft > scrollLeft + 10) {
                        targetImage = images[i];
                        break;
                    }
                }
                
                targetImage.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                return;
            }
        });

        // Video player controls
        document.addEventListener('DOMContentLoaded', () => {
            // Comment expand/collapse (click anywhere on left expand area)
            document.addEventListener('click', (event) => {
                const expandArea = event.target.closest('.comment-expand');
                if (!expandArea) return;

                const comment = expandArea.closest('.comment');
                const repliesContainer = comment.querySelector(':scope > .comment-content > .comment-replies');
                const expandBtn = expandArea.querySelector('.comment-expand-btn');

                if (!repliesContainer || !expandBtn) return;

                const isHidden = repliesContainer.hasAttribute('hidden');
                
                if (isHidden) {
                    repliesContainer.removeAttribute('hidden');
                    expandBtn.textContent = '‚àí';
                    expandBtn.classList.add('expanded');
                } else {
                    repliesContainer.setAttribute('hidden', '');
                    expandBtn.textContent = '+';
                    expandBtn.classList.remove('expanded');
                }
            });

            // Initialize videos and galleries
            initVideoControls(document);
            initGalleryLayout(document);
        });
        
        // Listen for dynamically added posts (infinite scroll)
        document.addEventListener('newPostsAdded', (event) => {
            const container = event.detail?.container || document;
            initVideoControls(container);
            initGalleryLayout(container);
        });
        
        // Gallery layout - center images if they don't overflow
        function initGalleryLayout(rootElement) {
            rootElement.querySelectorAll('.gallery-scroll').forEach(scroll => {
                // Check if content overflows
                const checkOverflow = () => {
                    if (scroll.scrollWidth > scroll.clientWidth) {
                        scroll.classList.add('overflow');
                    } else {
                        scroll.classList.remove('overflow');
                    }
                };
                
                // Check on load and when images load
                checkOverflow();
                scroll.querySelectorAll('img').forEach(img => {
                    if (img.complete) {
                        checkOverflow();
                    } else {
                        img.addEventListener('load', checkOverflow);
                    }
                });
                
                // Check on resize
                if (!scroll.dataset.resizeObserved) {
                    scroll.dataset.resizeObserved = 'true';
                    new ResizeObserver(checkOverflow).observe(scroll);
                }
            });
        }
        
        // Video controls initialization function
        function initVideoControls(rootElement) {
            rootElement.querySelectorAll('.video-container').forEach(container => {
                // Skip if already initialized
                if (container.dataset.videoInitialized) return;
                container.dataset.videoInitialized = 'true';
                const video = container.querySelector('.post-video');
                let audio = container.querySelector('.video-audio');
                const playPauseBtn = container.querySelector('.video-play-pause');
                const timeline = container.querySelector('.video-timeline');
                const progress = container.querySelector('.video-progress');
                const muteBtn = container.querySelector('.video-mute');
                const volumeSlider = container.querySelector('.video-volume-slider');
                const speedSelect = container.querySelector('.video-speed-select');
                const fullscreenBtn = container.querySelector('.video-fullscreen');
                
                let hls = null;
                let audioLoaded = false;

                // Get HLS URL from data attribute (has audio built-in)
                const hlsUrl = container.dataset.hlsUrl;
                const audioUrl = container.dataset.audioUrl;
                
                // Try HLS first - it has audio included
                if (hlsUrl && Hls.isSupported()) {
                    hls = new Hls();
                    hls.loadSource(hlsUrl);
                    hls.attachMedia(video);
                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        video.play().catch(() => {});
                    });
                    audioLoaded = true; // HLS has audio built-in
                } else if (hlsUrl && video.canPlayType('application/vnd.apple.mpegurl')) {
                    // Safari native HLS support
                    video.src = hlsUrl;
                    audioLoaded = true;
                }

                // Initialize video - default muted (no sound)
                video.muted = true;
                video.volume = 0;
                
                // Initialize audio element for synced playback (fallback when no HLS)
                // If no audio element exists but we have an audioUrl, create one
                if (!audio && audioUrl && !audioLoaded) {
                    audio = document.createElement('audio');
                    audio.src = audioUrl;
                    audio.style.display = 'none';
                    audio.loop = true;
                    audio.muted = true;
                    container.appendChild(audio);
                }
                
                if (audio && !audioLoaded) {
                    audio.volume = 0;
                    audio.muted = true;
                    
                    // Try to load audio, with fallback to 64kbps if 128 fails
                    audio.addEventListener('error', () => {
                        if (audio.src.includes('DASH_AUDIO_128')) {
                            audio.src = audio.src.replace('DASH_AUDIO_128', 'DASH_AUDIO_64');
                            audio.load();
                        }
                    }, { once: true });
                    
                    audio.load();
                    
                    // Sync audio with video
                    video.addEventListener('play', () => {
                        audio.currentTime = video.currentTime;
                        if (!audio.muted && audio.volume > 0) {
                            audio.play().catch(() => {});
                        }
                    });
                    video.addEventListener('pause', () => audio.pause());
                    video.addEventListener('seeked', () => {
                        audio.currentTime = video.currentTime;
                    });
                    
                    // Keep audio synced during playback
                    video.addEventListener('timeupdate', () => {
                        if (Math.abs(video.currentTime - audio.currentTime) > 0.3) {
                            audio.currentTime = video.currentTime;
                        }
                    });
                }
                
                // Update volume slider to 0
                volumeSlider.value = 0;
                muteBtn.textContent = 'üîá';

                // Play/Pause
                playPauseBtn.addEventListener('click', () => {
                    if (video.paused) {
                        // Pause all other videos
                        document.querySelectorAll('.post-video').forEach(v => {
                            if (v !== video) {
                                v.pause();
                                const vAudio = v.closest('.video-container').querySelector('.video-audio');
                                if (vAudio) vAudio.pause();
                                v.closest('.video-container').querySelector('.video-play-pause').textContent = '‚ñ∂';
                            }
                        });
                        video.play();
                        if (audio && audio.paused && audio.volume > 0) {
                            audio.play().catch(err => console.warn('Audio play failed:', err));
                        }
                        playPauseBtn.textContent = '‚è∏';
                    } else {
                        video.pause();
                        if (audio) audio.pause();
                        playPauseBtn.textContent = '‚ñ∂';
                    }
                });

                // Track if first click (for unmute)
                let firstClick = true;

                // Video click - first click unmutes to 5%, subsequent clicks toggle play/pause
                video.addEventListener('click', () => {
                    // First click unmutes to 5% volume
                    if (firstClick && (video.muted || video.volume === 0)) {
                        firstClick = false;
                        video.muted = false;
                        video.volume = 0.05;
                        if (audio) {
                            audio.muted = false;
                            audio.volume = 0.05;
                            audio.currentTime = video.currentTime;
                            if (!video.paused) {
                                audio.play().catch(() => {});
                            }
                        }
                        volumeSlider.value = 5;
                        muteBtn.textContent = 'üîâ';
                        return; // Don't toggle pause on first click
                    }
                    
                    firstClick = false;
                    
                    // Pause all other videos
                    document.querySelectorAll('.post-video').forEach(v => {
                        if (v !== video) {
                            v.pause();
                            const vAudio = v.closest('.video-container').querySelector('.video-audio');
                            if (vAudio) vAudio.pause();
                            v.closest('.video-container').querySelector('.video-play-pause').textContent = '‚ñ∂';
                        }
                    });
                    
                    // Toggle play/pause
                    if (video.paused) {
                        video.play();
                        if (audio && audio.volume > 0) {
                            audio.currentTime = video.currentTime;
                            audio.play().catch(() => {});
                        }
                        playPauseBtn.textContent = '‚è∏';
                    } else {
                        video.pause();
                        if (audio) audio.pause();
                        playPauseBtn.textContent = '‚ñ∂';
                    }
                });

                // Timeline
                timeline.addEventListener('click', (e) => {
                    const rect = timeline.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    video.currentTime = percent * video.duration;
                });

                // Update progress
                video.addEventListener('timeupdate', () => {
                    const percent = (video.currentTime / video.duration) * 100;
                    progress.style.width = percent + '%';
                });

                // Mute button
                muteBtn.addEventListener('click', () => {
                    video.muted = !video.muted;
                    if (audio) audio.muted = video.muted;
                    if (video.muted) {
                        muteBtn.textContent = 'üîá';
                    } else {
                        muteBtn.textContent = video.volume > 0.5 ? 'üîä' : 'üîâ';
                        if (video.volume === 0) {
                            video.volume = 0.3;
                            if (audio) audio.volume = 0.3;
                            volumeSlider.value = 30;
                        }
                    }
                });

                // Volume slider
                volumeSlider.addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value) / 100;
                    video.volume = volume;
                    if (audio) {
                        audio.volume = volume;
                        audio.muted = false;
                        // If audio is available and volume > 0, try to play it
                        if (volume > 0 && audio.paused && !video.paused) {
                            audio.currentTime = video.currentTime;
                            audio.play().catch(() => {});
                        }
                    }
                    video.muted = volume === 0;
                    if (volume === 0) {
                        muteBtn.textContent = 'üîá';
                        if (audio) audio.pause();
                    } else {
                        muteBtn.textContent = volume > 0.5 ? 'üîä' : 'üîâ';
                    }
                });

                // Playback speed dropdown
                speedSelect.addEventListener('change', (e) => {
                    const newSpeed = parseFloat(e.target.value);
                    video.playbackRate = newSpeed;
                    if (audio) audio.playbackRate = newSpeed;
                });

                // Fullscreen
                fullscreenBtn.addEventListener('click', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        container.requestFullscreen().catch(() => {
                            // Fallback for older browsers
                            if (container.webkitRequestFullscreen) {
                                container.webkitRequestFullscreen();
                            } else if (container.mozRequestFullScreen) {
                                container.mozRequestFullScreen();
                            }
                        });
                    }
                });

                // CTRL+Scroll for volume
                container.addEventListener('wheel', (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -5 : 5;
                        const newVolume = Math.max(0, Math.min(100, parseInt(volumeSlider.value) + delta));
                        volumeSlider.value = newVolume;
                        video.volume = newVolume / 100;
                        video.muted = newVolume === 0;
                        muteBtn.textContent = newVolume === 0 ? 'üîá' : (newVolume > 50 ? 'üîä' : 'üîâ');
                    }
                }, { passive: false });

                // Intersection Observer - auto play/pause based on visibility
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && entry.intersectionRatio >= 0.7) {
                            // Video is 70%+ visible - play it
                            if (video.paused) {
                                video.play().catch(() => {});
                                if (audio && !audio.muted && audio.volume > 0) {
                                    audio.currentTime = video.currentTime;
                                    audio.play().catch(() => {});
                                }
                                playPauseBtn.textContent = '‚è∏';
                            }
                        } else {
                            // Video is less than 70% visible - pause and mute it
                            if (!video.paused) {
                                video.pause();
                                if (audio) audio.pause();
                                playPauseBtn.textContent = '‚ñ∂';
                            }
                            // Auto-mute when scrolled out of view
                            video.muted = true;
                            video.volume = 0;
                            if (audio) {
                                audio.muted = true;
                                audio.volume = 0;
                            }
                            volumeSlider.value = 0;
                            muteBtn.textContent = 'üîá';
                            firstClick = true; // Reset so next click unmutes at 5%
                        }
                    });
                }, {
                    threshold: [0.7] // Trigger when 70% visibility changes
                });
                
                observer.observe(container);
            });
        }
    </script>
</body>
</html>
