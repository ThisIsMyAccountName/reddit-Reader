<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Reddit Reader{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest/dist/hls.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo-group">
                <a href="{{ url_for('index') }}" class="logo-icon" title="Go to r/all">üìñ</a>
                <a href="javascript:window.scrollTo(0,0);location.reload();" class="logo-text" title="Back to top & Refresh" style="cursor: pointer;">Reddit Reader</a>
            </div>
            <form action="{{ url_for('search') }}" method="get" class="search-form">
                <input type="text" 
                       name="q" 
                       class="search-input" 
                       placeholder="Search subreddit..."
                       autocomplete="off">
            </form>
            <div class="header-auth">
                {% if current_user.is_authenticated %}
                    <a href="{{ url_for('settings') }}" class="btn btn-small btn-icon" title="Settings">‚öôÔ∏è</a>
                    <span class="header-user">üë§ {{ current_user.username }}</span>
                    <a href="{{ url_for('logout') }}" class="btn btn-small">Logout</a>
                {% else %}
                    <a href="{{ url_for('login') }}" class="btn btn-small">Login</a>
                    <a href="{{ url_for('register') }}" class="btn btn-small btn-primary">Register</a>
                {% endif %}
            </div>
        </div>
    </header>
    <div class="header-spacer"></div>

    <main class="container">
        {% block content %}{% endblock %}
    </main>
    
    <!-- Back to Top Button -->
    <button class="back-to-top" id="back-to-top" title="Back to top">‚Üë</button>

    <script>
        // Default playback settings from user preferences
        window.defaultVolume = {{ default_volume }} / 100;
        window.defaultSpeed = {{ default_speed }};
        
        // Track collapsed comment state per post
        const postCommentStates = new Map();
        
        // Back to top button
        (function() {
            const backToTop = document.getElementById('back-to-top');
            let ticking = false;
            
            function updateBackToTop() {
                if (window.scrollY > 500) {
                    backToTop.classList.add('visible');
                } else {
                    backToTop.classList.remove('visible');
                }
                ticking = false;
            }
            
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    requestAnimationFrame(updateBackToTop);
                    ticking = true;
                }
            });
            
            backToTop.addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        })();
        
        // Header hide/show on scroll and mouse
        (function() {
            const header = document.querySelector('.header');
            let lastScrollY = window.scrollY;
            let ticking = false;
            
            function updateHeader() {
                const currentScrollY = window.scrollY;
                
                // Show header at top of page or when scrolling up
                if (currentScrollY <= 50 || currentScrollY < lastScrollY) {
                    header.classList.remove('header-hidden');
                } 
                // Hide when scrolling down
                else if (currentScrollY > lastScrollY) {
                    header.classList.add('header-hidden');
                }
                
                lastScrollY = currentScrollY;
                ticking = false;
            }
            
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    requestAnimationFrame(updateHeader);
                    ticking = true;
                }
            });
            
            // Show header when mouse moves to top of viewport
            document.addEventListener('mousemove', (e) => {
                if (e.clientY <= 50) {
                    header.classList.remove('header-hidden');
                }
            });
        })();

        document.addEventListener('click', async (event) => {
            // Ignore clicks on links, buttons, and interactive elements
            if (event.target.closest('a, button, input, select, textarea, .comment, .post-media')) {
                return;
            }
            
            const post = event.target.closest('.post');
            if (!post) return;
            
            event.preventDefault();
            event.stopPropagation();

            const container = post.querySelector('.post-top-comments');
            const list = container.querySelector('.comment-list');
            const isVisible = !list.hasAttribute('hidden');
            
            // If comments are visible, hide them
            if (isVisible) {
                // Save collapsed state before hiding
                const collapsedComments = new Set();
                list.querySelectorAll('.comment').forEach(comment => {
                    const repliesContainer = comment.querySelector(':scope > .comment-content > .comment-replies');
                    if (repliesContainer && repliesContainer.hasAttribute('hidden')) {
                        const commentId = comment.dataset.commentId;
                        if (commentId) {
                            collapsedComments.add(commentId);
                        }
                    }
                });
                postCommentStates.set(postId, collapsedComments);
                
                list.setAttribute('hidden', '');
                container.classList.remove('has-comments');
                const loadMoreContainer = container.querySelector('.load-more-comments-container');
                if (loadMoreContainer) {
                    loadMoreContainer.setAttribute('hidden', '');
                }
                return;
            }
            
            // Otherwise, load more comments
            const subreddit = post.dataset.subreddit;
            const postId = post.dataset.postId;
            const increment = parseInt(post.dataset.increment) || 3;
            let currentLimit = parseInt(post.dataset.currentLimit) || 0;

            const newLimit = currentLimit + increment;
            
            try {
                const response = await fetch(`/api/comments?subreddit=${encodeURIComponent(subreddit)}&post_id=${encodeURIComponent(postId)}&limit=${encodeURIComponent(newLimit)}`);
                const data = await response.json();
                list.innerHTML = '';

                if (data.comments && data.comments.length) {
                    const showAuthor = list.dataset.showAuthor !== 'false';
                    data.comments.forEach((comment) => {
                        list.appendChild(createCommentElement(comment, 0, showAuthor));
                    });
                    
                    // Expand all comment threads after loading
                    list.querySelectorAll('.comment-replies').forEach(replies => {
                        replies.removeAttribute('hidden');
                    });
                    
                    // Restore collapsed state if exists
                    const savedState = postCommentStates.get(postId);
                    if (savedState) {
                        list.querySelectorAll('.comment').forEach(comment => {
                            const commentId = comment.dataset.commentId;
                            if (commentId && savedState.has(commentId)) {
                                const repliesContainer = comment.querySelector(':scope > .comment-content > .comment-replies');
                                if (repliesContainer) {
                                    repliesContainer.setAttribute('hidden', '');
                                }
                            }
                        });
                    }
                    
                    list.removeAttribute('hidden');
                    container.classList.add('has-comments');
                    post.dataset.currentLimit = data.comments.length;
                    
                    // Show load more button
                    const loadMoreContainer = container.querySelector('.load-more-comments-container');
                    if (loadMoreContainer) {
                        loadMoreContainer.removeAttribute('hidden');
                    }
                } else {
                    const empty = document.createElement('div');
                    empty.className = 'text-secondary';
                    empty.style.fontSize = '13px';
                    empty.textContent = 'No comments found.';
                    list.appendChild(empty);
                    list.removeAttribute('hidden');
                    container.classList.add('has-comments');
                }
            } catch (err) {
                console.error('Failed to load comments:', err);
            }
        });

        // Load more comments button
        document.addEventListener('click', async (event) => {
            const loadMoreBtn = event.target.closest('.load-more-comments-btn');
            if (!loadMoreBtn) return;
            
            event.stopPropagation();
            
            const post = loadMoreBtn.closest('.post');
            if (!post) return;
            
            const container = post.querySelector('.post-top-comments');
            const list = container.querySelector('.comment-list');
            const subreddit = post.dataset.subreddit;
            const postId = post.dataset.postId;
            const increment = parseInt(post.dataset.increment) || 3;
            let currentLimit = parseInt(post.dataset.currentLimit) || 0;
            
            const newLimit = currentLimit + increment;
            
            try {
                // Get saved collapsed state for this post
                const savedState = postCommentStates.get(postId) || new Set();
                
                // Merge with current collapsed state
                list.querySelectorAll('.comment').forEach(comment => {
                    const repliesContainer = comment.querySelector(':scope > .comment-content > .comment-replies');
                    if (repliesContainer && repliesContainer.hasAttribute('hidden')) {
                        const commentId = comment.dataset.commentId;
                        if (commentId) {
                            savedState.add(commentId);
                        }
                    }
                });
                
                const response = await fetch(`/api/comments?subreddit=${encodeURIComponent(subreddit)}&post_id=${encodeURIComponent(postId)}&limit=${encodeURIComponent(newLimit)}`);
                const data = await response.json();
                list.innerHTML = '';
                
                if (data.comments && data.comments.length) {
                    const showAuthor = list.dataset.showAuthor !== 'false';
                    data.comments.forEach((comment) => {
                        list.appendChild(createCommentElement(comment, 0, showAuthor));
                    });
                    
                    // Expand all comment threads after loading
                    list.querySelectorAll('.comment-replies').forEach(replies => {
                        replies.removeAttribute('hidden');
                    });
                    
                    // Restore collapsed state
                    list.querySelectorAll('.comment').forEach(comment => {
                        const commentId = comment.dataset.commentId;
                        if (commentId && savedState.has(commentId)) {
                            const repliesContainer = comment.querySelector(':scope > .comment-content > .comment-replies');
                            if (repliesContainer) {
                                repliesContainer.setAttribute('hidden', '');
                            }
                        }
                    });
                    
                    // Update saved state
                    postCommentStates.set(postId, savedState);
                    
                    post.dataset.currentLimit = data.comments.length;
                    
                    // Hide load more button if we got fewer comments than requested
                    if (data.comments.length < newLimit) {
                        const loadMoreContainer = container.querySelector('.load-more-comments-container');
                        if (loadMoreContainer) {
                            loadMoreContainer.setAttribute('hidden', '');
                        }
                    }
                }
            } catch (err) {
                console.error('Failed to load more comments:', err);
            }
        });

        // Close context menu on any click
        document.addEventListener('click', () => {
            closeDownloadMenu();
        });

        // Right-click on media to open download menu
        document.addEventListener('contextmenu', (event) => {
            const video = event.target.closest('.post-video');
            const image = event.target.closest('.post-image, .gallery-image');
            
            let url = null;
            if (video) {
                url = video.src || video.currentSrc;
            } else if (image) {
                url = image.src || image.currentSrc;
            }
            
            if (url) {
                event.preventDefault();
                openDownloadMenu(event.clientX, event.clientY, url);
            }
        });

        function openDownloadMenu(x, y, url) {
            closeDownloadMenu();

            const menu = document.createElement('div');
            menu.className = 'media-download-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;

            const downloadBtn = document.createElement('button');
            downloadBtn.textContent = 'Download';
            downloadBtn.addEventListener('click', () => {
                const filename = getFilenameFromUrl(url);
                triggerDownload(url, filename);
                closeDownloadMenu();
            });

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Download as...';
            renameBtn.addEventListener('click', async () => {
                const defaultName = getFilenameFromUrl(url);
                const customName = prompt('Save file as:', defaultName);
                if (customName) {
                    await triggerDownload(url, customName);
                }
                closeDownloadMenu();
            });

            menu.appendChild(downloadBtn);
            menu.appendChild(renameBtn);
            document.body.appendChild(menu);
        }

        function closeDownloadMenu() {
            document.querySelectorAll('.media-download-menu').forEach(menu => menu.remove());
        }

        function getFilenameFromUrl(url) {
            try {
                const parsed = new URL(url);
                const pathname = parsed.pathname.split('/').pop() || 'media';
                return decodeURIComponent(pathname.split('?')[0]);
            } catch {
                return 'media';
            }
        }

        async function triggerDownload(url, filename) {
            try {
                const response = await fetch(url, { mode: 'cors' });
                const blob = await response.blob();
                const objectUrl = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = objectUrl;
                link.download = filename || 'media';
                document.body.appendChild(link);
                link.click();
                link.remove();
                URL.revokeObjectURL(objectUrl);
            } catch {
                window.open(url, '_blank');
            }
        }

        function createCommentElement(comment, depth = 0, showAuthor = true) {
            const item = document.createElement('div');
            item.className = depth > 0 ? 'comment compact comment-reply' : 'comment compact';
            item.dataset.depth = depth;
            item.dataset.commentId = comment.id || '';

            // Content container
            const contentDiv = document.createElement('div');
            contentDiv.className = 'comment-content';

            const score = document.createElement('span');
            score.className = 'comment-score';
            score.textContent = `‚¨ÜÔ∏è ${comment.score.toLocaleString()}`;

            const meta = document.createElement('div');
            meta.className = 'comment-meta-right';
            if (showAuthor) {
                const author = document.createElement('span');
                author.className = 'comment-author';
                author.textContent = `u/${comment.author}`;
                meta.appendChild(author);
            }
            meta.appendChild(score);

            const body = document.createElement('div');
            body.className = 'comment-body';
            body.innerHTML = comment.formatted_body || comment.body;

            contentDiv.appendChild(meta);
            contentDiv.appendChild(body);

            // Add replies if present
            if (comment.replies && comment.replies.length > 0) {
                const repliesDiv = document.createElement('div');
                repliesDiv.className = 'comment-replies';
                repliesDiv.setAttribute('hidden', '');
                
                comment.replies.forEach(reply => {
                    repliesDiv.appendChild(createCommentElement(reply, depth + 1, showAuthor));
                });
                
                contentDiv.appendChild(repliesDiv);
            }

            item.appendChild(contentDiv);
            return item;
        }

        // Gallery navigation
        document.addEventListener('click', (event) => {
            const navLeft = event.target.closest('.gallery-nav-left');
            const navRight = event.target.closest('.gallery-nav-right');
            
            if (navLeft) {
                const scroll = navLeft.parentElement.querySelector('.gallery-scroll');
                const images = Array.from(scroll.children);
                const scrollLeft = scroll.scrollLeft;
                
                let targetImage = images[0];
                for (let i = images.length - 1; i >= 0; i--) {
                    if (images[i].offsetLeft < scrollLeft - 10) {
                        targetImage = images[i];
                        break;
                    }
                }
                
                targetImage.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                return;
            }
            
            if (navRight) {
                const scroll = navRight.parentElement.querySelector('.gallery-scroll');
                const images = Array.from(scroll.children);
                const scrollLeft = scroll.scrollLeft;
                
                let targetImage = images[images.length - 1];
                for (let i = 0; i < images.length; i++) {
                    if (images[i].offsetLeft > scrollLeft + 10) {
                        targetImage = images[i];
                        break;
                    }
                }
                
                targetImage.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                return;
            }
        });

        // Video player controls
        document.addEventListener('DOMContentLoaded', () => {
            // Comment expand/collapse (click anywhere on comment to toggle)
            document.addEventListener('click', (event) => {
                const comment = event.target.closest('.comment');
                if (!comment) return;

                // Don't toggle if clicking on links, buttons, or inputs
                if (event.target.closest('a, button, input')) return;

                const repliesContainer = comment.querySelector(':scope > .comment-content > .comment-replies');

                if (!repliesContainer) return;

                const isHidden = repliesContainer.hasAttribute('hidden');
                
                if (isHidden) {
                    repliesContainer.removeAttribute('hidden');
                } else {
                    repliesContainer.setAttribute('hidden', '');
                }
            });

            // Initialize videos and galleries
            initVideoControls(document);
            initGalleryLayout(document);
        });
        
        // Listen for dynamically added posts (infinite scroll)
        document.addEventListener('newPostsAdded', (event) => {
            const container = event.detail?.container || document;
            initVideoControls(container);
            initGalleryLayout(container);
        });
        
        // Gallery layout - center images if they don't overflow
        function initGalleryLayout(rootElement) {
            rootElement.querySelectorAll('.gallery-scroll').forEach(scroll => {
                // Check if content overflows
                const checkOverflow = () => {
                    if (scroll.scrollWidth > scroll.clientWidth) {
                        scroll.classList.add('overflow');
                    } else {
                        scroll.classList.remove('overflow');
                    }
                };
                
                // Check on load and when images load
                checkOverflow();
                scroll.querySelectorAll('img').forEach(img => {
                    if (img.complete) {
                        checkOverflow();
                    } else {
                        img.addEventListener('load', checkOverflow);
                    }
                });
                
                // Check on resize
                if (!scroll.dataset.resizeObserved) {
                    scroll.dataset.resizeObserved = 'true';
                    new ResizeObserver(checkOverflow).observe(scroll);
                }
            });
        }
        
        // Video controls initialization function
        function initVideoControls(rootElement) {
            rootElement.querySelectorAll('.video-container').forEach(container => {
                // Skip if already initialized
                if (container.dataset.videoInitialized) return;
                container.dataset.videoInitialized = 'true';
                const video = container.querySelector('.post-video');
                let audio = container.querySelector('.video-audio');
                const playPauseBtn = container.querySelector('.video-play-pause');
                const timeline = container.querySelector('.video-timeline');
                const progress = container.querySelector('.video-progress');
                const muteBtn = container.querySelector('.video-mute');
                const volumeSlider = container.querySelector('.video-volume-slider');
                const speedSelect = container.querySelector('.video-speed-select');
                const fullscreenBtn = container.querySelector('.video-fullscreen');
                
                let hls = null;
                let audioLoaded = false;

                // Get HLS URL from data attribute (has audio built-in)
                const hlsUrl = container.dataset.hlsUrl;
                const audioUrl = container.dataset.audioUrl;
                
                // Try HLS first - it has audio included
                if (hlsUrl && Hls.isSupported()) {
                    hls = new Hls();
                    hls.loadSource(hlsUrl);
                    hls.attachMedia(video);
                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        video.play().catch(() => {});
                    });
                    audioLoaded = true; // HLS has audio built-in
                } else if (hlsUrl && video.canPlayType('application/vnd.apple.mpegurl')) {
                    // Safari native HLS support
                    video.src = hlsUrl;
                    audioLoaded = true;
                }

                // Initialize video - default muted (no sound)
                video.muted = true;
                video.volume = 0;
                
                // Initialize audio element for synced playback (fallback when no HLS)
                // If no audio element exists but we have an audioUrl, create one
                if (!audio && audioUrl && !audioLoaded) {
                    audio = document.createElement('audio');
                    audio.src = audioUrl;
                    audio.style.display = 'none';
                    audio.loop = true;
                    audio.muted = true;
                    container.appendChild(audio);
                }
                
                if (audio && !audioLoaded) {
                    audio.volume = 0;
                    audio.muted = true;
                    
                    // Try to load audio, with fallback to 64kbps if 128 fails
                    audio.addEventListener('error', () => {
                        if (audio.src.includes('DASH_AUDIO_128')) {
                            audio.src = audio.src.replace('DASH_AUDIO_128', 'DASH_AUDIO_64');
                            audio.load();
                        }
                    }, { once: true });
                    
                    audio.load();
                    
                    // Sync audio with video
                    video.addEventListener('play', () => {
                        audio.currentTime = video.currentTime;
                        if (!audio.muted && audio.volume > 0) {
                            audio.play().catch(() => {});
                        }
                    });
                    video.addEventListener('pause', () => audio.pause());
                    video.addEventListener('seeked', () => {
                        audio.currentTime = video.currentTime;
                    });
                    
                    // Keep audio synced during playback
                    video.addEventListener('timeupdate', () => {
                        if (Math.abs(video.currentTime - audio.currentTime) > 0.3) {
                            audio.currentTime = video.currentTime;
                        }
                    });
                }
                
                // Update volume slider to 0
                volumeSlider.value = 0;
                muteBtn.textContent = 'üîá';

                // Play/Pause
                playPauseBtn.addEventListener('click', () => {
                    if (video.paused) {
                        // Pause all other videos
                        document.querySelectorAll('.post-video').forEach(v => {
                            if (v !== video) {
                                v.pause();
                                const vAudio = v.closest('.video-container').querySelector('.video-audio');
                                if (vAudio) vAudio.pause();
                                v.closest('.video-container').querySelector('.video-play-pause').textContent = '‚ñ∂';
                            }
                        });
                        video.play();
                        if (audio && audio.paused && audio.volume > 0) {
                            audio.play().catch(err => console.warn('Audio play failed:', err));
                        }
                        playPauseBtn.textContent = '‚è∏';
                    } else {
                        video.pause();
                        if (audio) audio.pause();
                        playPauseBtn.textContent = '‚ñ∂';
                    }
                });

                // Track if first click (for unmute)
                let firstClick = true;
                const userDefaultVolume = window.defaultVolume || 0.05;
                const userDefaultSpeed = window.defaultSpeed || 1.0;
                
                // Set default playback speed
                video.playbackRate = userDefaultSpeed;
                if (speedSelect) speedSelect.value = userDefaultSpeed;

                // Video click - first click unmutes to default volume, subsequent clicks toggle play/pause
                video.addEventListener('click', () => {
                    // First click unmutes to user's default volume
                    if (firstClick && (video.muted || video.volume === 0)) {
                        firstClick = false;
                        video.muted = false;
                        video.volume = userDefaultVolume;
                        if (audio) {
                            audio.muted = false;
                            audio.volume = userDefaultVolume;
                            audio.currentTime = video.currentTime;
                            if (!video.paused) {
                                audio.play().catch(() => {});
                            }
                        }
                        volumeSlider.value = userDefaultVolume * 100;
                        muteBtn.textContent = userDefaultVolume > 0.5 ? 'üîä' : 'üîâ';
                        return; // Don't toggle pause on first click
                    }
                    
                    firstClick = false;
                    
                    // Pause all other videos
                    document.querySelectorAll('.post-video').forEach(v => {
                        if (v !== video) {
                            v.pause();
                            const vAudio = v.closest('.video-container').querySelector('.video-audio');
                            if (vAudio) vAudio.pause();
                            v.closest('.video-container').querySelector('.video-play-pause').textContent = '‚ñ∂';
                        }
                    });
                    
                    // Toggle play/pause
                    if (video.paused) {
                        video.play();
                        if (audio && audio.volume > 0) {
                            audio.currentTime = video.currentTime;
                            audio.play().catch(() => {});
                        }
                        playPauseBtn.textContent = '‚è∏';
                    } else {
                        video.pause();
                        if (audio) audio.pause();
                        playPauseBtn.textContent = '‚ñ∂';
                    }
                });

                // Timeline - click and drag support
                let isDragging = false;
                
                const updateVideoTime = (e) => {
                    const rect = timeline.getBoundingClientRect();
                    const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                    video.currentTime = percent * video.duration;
                    // Update progress bar immediately while dragging
                    progress.style.width = (percent * 100) + '%';
                };
                
                timeline.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    updateVideoTime(e);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        updateVideoTime(e);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                timeline.addEventListener('click', (e) => {
                    updateVideoTime(e);
                });

                // Update progress
                video.addEventListener('timeupdate', () => {
                    if (!isDragging) {
                        const percent = (video.currentTime / video.duration) * 100;
                        progress.style.width = percent + '%';
                    }
                });

                // Mute button
                muteBtn.addEventListener('click', () => {
                    video.muted = !video.muted;
                    if (audio) audio.muted = video.muted;
                    if (video.muted) {
                        muteBtn.textContent = 'üîá';
                    } else {
                        muteBtn.textContent = video.volume > 0.5 ? 'üîä' : 'üîâ';
                        if (video.volume === 0) {
                            video.volume = 0.3;
                            if (audio) audio.volume = 0.3;
                            volumeSlider.value = 30;
                        }
                    }
                });

                // Volume slider
                volumeSlider.addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value) / 100;
                    video.volume = volume;
                    if (audio) {
                        audio.volume = volume;
                        audio.muted = false;
                        // If audio is available and volume > 0, try to play it
                        if (volume > 0 && audio.paused && !video.paused) {
                            audio.currentTime = video.currentTime;
                            audio.play().catch(() => {});
                        }
                    }
                    video.muted = volume === 0;
                    if (volume === 0) {
                        muteBtn.textContent = 'üîá';
                        if (audio) audio.pause();
                    } else {
                        muteBtn.textContent = volume > 0.5 ? 'üîä' : 'üîâ';
                    }
                });

                // Playback speed dropdown
                speedSelect.addEventListener('change', (e) => {
                    const newSpeed = parseFloat(e.target.value);
                    video.playbackRate = newSpeed;
                    if (audio) audio.playbackRate = newSpeed;
                });

                // Fullscreen
                fullscreenBtn.addEventListener('click', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        container.requestFullscreen().catch(() => {
                            // Fallback for older browsers
                            if (container.webkitRequestFullscreen) {
                                container.webkitRequestFullscreen();
                            } else if (container.mozRequestFullScreen) {
                                container.mozRequestFullScreen();
                            }
                        });
                    }
                });

                // CTRL+Scroll for volume
                container.addEventListener('wheel', (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -5 : 5;
                        const newVolume = Math.max(0, Math.min(100, parseInt(volumeSlider.value) + delta));
                        volumeSlider.value = newVolume;
                        video.volume = newVolume / 100;
                        video.muted = newVolume === 0;
                        muteBtn.textContent = newVolume === 0 ? 'üîá' : (newVolume > 50 ? 'üîä' : 'üîâ');
                    }
                }, { passive: false });

                // Intersection Observer - auto play/pause based on visibility
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && entry.intersectionRatio >= 0.7) {
                            // Video is 70%+ visible - play it
                            if (video.paused) {
                                video.play().catch(() => {});
                                if (audio && !audio.muted && audio.volume > 0) {
                                    audio.currentTime = video.currentTime;
                                    audio.play().catch(() => {});
                                }
                                playPauseBtn.textContent = '‚è∏';
                            }
                        } else {
                            // Video is less than 70% visible - pause and mute it
                            if (!video.paused) {
                                video.pause();
                                if (audio) audio.pause();
                                playPauseBtn.textContent = '‚ñ∂';
                            }
                            // Auto-mute when scrolled out of view
                            video.muted = true;
                            video.volume = 0;
                            if (audio) {
                                audio.muted = true;
                                audio.volume = 0;
                            }
                            volumeSlider.value = 0;
                            muteBtn.textContent = 'üîá';
                            firstClick = true; // Reset so next click unmutes at 5%
                        }
                    });
                }, {
                    threshold: [0.7] // Trigger when 70% visibility changes
                });
                
                observer.observe(container);
            });
        }
    </script>
</body>
</html>
