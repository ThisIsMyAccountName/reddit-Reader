{% extends "base.html" %}

{% block title %}r/{{ subreddit }} - Reddit Reader{% endblock %}

{% block content %}
<!-- Mini navigation sidebar -->
<div class="mini-nav {% if sidebar_position == 'right' %}mini-nav-right{% elif sidebar_position == 'off' %}mini-nav-hidden{% endif %}" id="mini-nav">
    <div class="mini-nav-title">Posts</div>
    <div class="mini-nav-viewport" id="mini-nav-viewport"></div>
    <div class="mini-nav-items" id="mini-nav-items">
        {% for post in posts %}
        <a href="#post-{{ loop.index }}" class="mini-nav-item" data-post-index="{{ loop.index }}" title="{{ post.title }}">
            {% if post.thumbnail and post.thumbnail.startswith('http') %}
            <img src="{{ post.thumbnail }}" alt="" class="mini-nav-thumb">
            {% elif post.image_url %}
            <img src="{{ post.image_url }}" alt="" class="mini-nav-thumb">
            {% elif post.is_self %}
            <div class="mini-nav-placeholder">üìù</div>
            {% else %}
            <div class="mini-nav-placeholder">üîó</div>
            {% endif %}
        </a>
        {% endfor %}
    </div>
</div>

<div class="main-content">
<div class="subreddit-nav">
    {% if current_user.is_authenticated and pinned_subs %}
        {% for sub in pinned_subs %}
        <a href="{{ url_for('subreddit', name=sub) }}" class="subreddit-link {% if sub == subreddit %}active{% endif %}">r/{{ sub }}</a>
        {% endfor %}
        {% if subreddit not in pinned_subs %}
        <span class="subreddit-link active">r/{{ subreddit }}</span>
        {% endif %}
    {% else %}
        <a href="{{ url_for('subreddit', name='all') }}" class="subreddit-link {% if subreddit == 'all' %}active{% endif %}">r/all</a>
        <a href="{{ url_for('subreddit', name='popular') }}" class="subreddit-link {% if subreddit == 'popular' %}active{% endif %}">r/popular</a>
        {% if subreddit not in ['all', 'popular'] %}
        <span class="subreddit-link active">r/{{ subreddit }}</span>
        {% endif %}
    {% endif %}
</div>

<div class="controls">
    <a href="{{ url_for('subreddit', name=subreddit, sort='hot') }}" 
       class="sort-link {% if sort == 'hot' %}active{% endif %}">üî• Hot</a>
    <a href="{{ url_for('subreddit', name=subreddit, sort='new') }}" 
       class="sort-link {% if sort == 'new' %}active{% endif %}">üÜï New</a>
    <a href="{{ url_for('subreddit', name=subreddit, sort='top', t=time_filter or 'day') }}" 
       class="sort-link {% if sort == 'top' %}active{% endif %}">‚≠ê Top</a>
    <a href="{{ url_for('subreddit', name=subreddit, sort='rising') }}" 
       class="sort-link {% if sort == 'rising' %}active{% endif %}">üìà Rising</a>
    
    {% if sort == 'top' %}
    <span class="time-filter-divider">|</span>
    <select id="time-filter" class="time-filter-select" onchange="window.location.href=this.value">
        <option value="{{ url_for('subreddit', name=subreddit, sort='top', t='hour') }}" {% if time_filter == 'hour' %}selected{% endif %}>Past Hour</option>
        <option value="{{ url_for('subreddit', name=subreddit, sort='top', t='day') }}" {% if time_filter == 'day' %}selected{% endif %}>Today</option>
        <option value="{{ url_for('subreddit', name=subreddit, sort='top', t='week') }}" {% if time_filter == 'week' %}selected{% endif %}>This Week</option>
        <option value="{{ url_for('subreddit', name=subreddit, sort='top', t='month') }}" {% if time_filter == 'month' %}selected{% endif %}>This Month</option>
        <option value="{{ url_for('subreddit', name=subreddit, sort='top', t='year') }}" {% if time_filter == 'year' %}selected{% endif %}>This Year</option>
        <option value="{{ url_for('subreddit', name=subreddit, sort='top', t='all') }}" {% if time_filter == 'all' %}selected{% endif %}>All Time</option>
    </select>
    {% endif %}
</div>

<div id="posts-container" 
     data-subreddit="{{ subreddit }}" 
     data-sort="{{ sort }}" 
     data-time-filter="{{ time_filter or 'day' }}"
     data-after="{{ after or '' }}"
     data-comments-limit="{{ comments_limit }}">
{% if posts %}
    {% for post in posts %}
    <article class="post" id="post-{{ loop.index }}" 
             data-post-index="{{ loop.index }}" 
             data-post-id="{{ post.id }}"
             data-thumbnail="{{ post.thumbnail or post.image_url or '' }}"
             data-subreddit="{{ post.subreddit }}"
             data-post-id="{{ post.id }}"
             data-current-limit="0"
             data-increment="3"
             style="cursor: pointer;">
        <div class="post-header">
            <div class="post-meta-left">
                <a href="{{ url_for('subreddit', name=post.subreddit) }}" class="subreddit-link-inline trunc">r/{{ post.subreddit }}</a>
                <span class="meta-text post-author trunc">u/{{ post.author }}</span>
            </div>
            <div class="post-meta-actions">
                <span class="meta-text post-upvotes">‚¨ÜÔ∏è{{ post.score }}</span>
                {% if current_user.is_authenticated %}
                    {% if post.subreddit in feed_pinned_subs %}
                    <form method="post" action="{{ url_for('unpin_subreddit', subreddit=post.subreddit) }}" class="inline-form">
                        <button type="submit" class="meta-action-btn unpin-btn" title="Unpin r/{{ post.subreddit }}">üìç</button>
                    </form>
                    {% elif post.subreddit not in pinned_subs %}
                    <form method="post" action="{{ url_for('pin_subreddit', subreddit=post.subreddit) }}" class="inline-form">
                        <button type="submit" class="meta-action-btn pin-btn" title="Pin r/{{ post.subreddit }}">üìå</button>
                    </form>
                    {% endif %}
                {% endif %}
                <a href="{{ url_for('share_post', subreddit=post.subreddit, post_id=post.id) }}" class="meta-action-btn share-btn" data-share-path="{{ url_for('share_post', subreddit=post.subreddit, post_id=post.id) }}" title="Share" rel="noopener noreferrer">üîÅ</a>
                <a href="{{ post.permalink }}" target="_blank" class="meta-action-btn" title="Reddit">üì§</a>
                {% if current_user.is_authenticated and post.subreddit != subreddit %}
                <form method="post" action="{{ url_for('ban_subreddit', subreddit=post.subreddit) }}" class="inline-form" onsubmit="return confirm('Ban r/{{ post.subreddit }}? Posts from this subreddit will be hidden.')">
                    <button type="submit" class="meta-action-btn ban-btn" title="Ban r/{{ post.subreddit }}">üö´</button>
                </form>
                {% endif %}
            </div>
            <button class="meta-menu-toggle" aria-haspopup="true" aria-expanded="false" title="Actions">‚ò∞</button>
            <div class="meta-menu" hidden aria-hidden="true"></div>
        </div>

        <h2 class="post-title">
            {% if title_links %}
            <a href="{{ url_for('comments', subreddit=post.subreddit, post_id=post.id) }}">{{ post.title }}</a>
            {% else %}
            <span class="post-title-text">{{ post.title }}</span>
            {% endif %}
        </h2>
        
        {% if post.is_video and (post.hls_url or post.video_url) %}
        <div class="post-media video-container" data-hls-url="{{ post.hls_url }}" data-audio-url="{{ post.audio_url }}">
            <video class="post-video" src="{{ post.video_url }}" loop playsinline autoplay muted></video>
            {% if post.audio_url %}
            <audio class="video-audio" src="{{ post.audio_url }}" style="display:none;" loop muted></audio>
            {% endif %}
            <div class="video-controls">
                
                <div class="video-timeline">
                    <div class="video-progress"></div>
                </div>
                <div class="video-volume-container">
                    <button class="video-btn video-mute" aria-label="Mute">üîá</button>
                    <input type="range" class="video-volume-slider" min="0" max="100" value="0">
                </div>
                <div class="video-speed-container">
                    <button class="video-btn video-speed-decrease" aria-label="Decrease speed">‚àí</button>
                    <div class="video-speed-display">1x</div>
                    <button class="video-btn video-speed-increase" aria-label="Increase speed">+</button>
                </div>
                <button class="video-btn video-fullscreen" aria-label="Fullscreen">‚õ∂</button>
            </div>
        </div>
        {% elif post.gallery_urls and post.gallery_urls|length > 0 %}
        <div class="post-media gallery">
            <div class="gallery-preview" tabindex="0" role="button" aria-expanded="false">
                <div class="gallery-preview-main">
                    <img class="gallery-image preview-main" src="{{ post.gallery_urls[0] }}" alt="Gallery image" loading="lazy">
                </div>
                {% if post.gallery_urls|length > 1 %}
                <div class="gallery-preview-peek">
                    <img class="gallery-image preview-peek" src="{{ post.gallery_urls[1] }}" alt="Gallery image peek" loading="lazy">
                    {% if post.gallery_urls|length > 2 %}
                    <div class="gallery-more-count">+{{ post.gallery_urls|length - 1 }}</div>
                    {% endif %}
                </div>
                {% endif %}
            </div>

            <div class="gallery-scroll gallery-full" hidden>
                {% for url in post.gallery_urls %}
                <div class="gallery-item">
                    <img class="gallery-image" src="{{ url }}" alt="Gallery image" loading="lazy">
                </div>
                {% endfor %}
            </div>

            <!-- navigation buttons removed; preview below main image shows second image -->
        </div>
        {% elif post.image_url %}
        <div class="post-media">
            <img class="post-image" src="{{ post.image_url }}" alt="Post image">
        </div>
        {% endif %}

        {% if post.selftext %}
        <div class="post-text-content">
            {{ post.selftext | format_content | safe }}
        </div>
        <div class="post-text-toggle" title="Toggle post text" aria-hidden="true"></div>
        {% endif %}
        


        <div class="post-top-comments" hidden>
            <div class="comment-list" data-show-author="false" hidden></div>
            <div class="load-more-comments-container" hidden style="text-align: center; padding: 10px 0;">
                <button class="btn load-more-comments-btn">Load 3 more comments</button>
            </div>
        </div>
    </article>
    {% endfor %}
</div>

<div id="loading-indicator" style="display: none; text-align: center; padding: 20px;">
    <span class="text-secondary">Loading more posts...</span>
</div>

<div id="no-more-posts" style="display: none; text-align: center; padding: 20px;">
    <span class="text-secondary">No more posts to load</span>
</div>
</div><!-- close main-content -->

{% else %}
    <div class="error-container">
        <div class="error-title">üòï</div>
        <p class="error-message">No posts found for r/{{ subreddit }}</p>
        <a href="{{ url_for('index') }}" class="btn btn-primary">Go to r/all</a>
    </div>
</div>
</div>
{% endif %}

<script>
(function() {
    const container = document.getElementById('posts-container');
    if (!container) return;
    // Attach copy-to-clipboard handler for share buttons (works for server and client rendered posts)
    function setupShareButtons(root=document) {
        const shareBtns = root.querySelectorAll('.share-btn');
        shareBtns.forEach(btn => {
            if (btn._shareHandlerAttached) return;
            btn._shareHandlerAttached = true;
            btn.addEventListener('click', async (e) => {
                // Only intercept primary (left) clicks without modifier keys ‚Äî allow middle-click/new-tab
                if (e.button !== 0 || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;
                e.preventDefault();
                e.stopPropagation();
                const path = btn.getAttribute('data-share-path') || '';
                const url = path.startsWith('http') ? path : (window.location.origin + path);
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(url);
                    } else {
                        const ta = document.createElement('textarea');
                        ta.value = url;
                        document.body.appendChild(ta);
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                    }
                    const original = btn.textContent;
                    btn.textContent = '‚úÖ';
                    btn.disabled = true;
                    setTimeout(() => { btn.textContent = original; btn.disabled = false; }, 1500);
                } catch (err) {
                    console.error('Copy failed', err);
                }
            });
        });
    }

    // initial setup (for server rendered buttons)
    setupShareButtons(document);

    // observe for dynamically added posts (client-side rendering)
    const observer = new MutationObserver((mutations) => {
        for (const m of mutations) {
            if (m.addedNodes && m.addedNodes.length) setupShareButtons(m.target);
        }
    });
    observer.observe(container, { childList: true, subtree: true });

    const subreddit = container.dataset.subreddit;
    const sort = container.dataset.sort;
    const timeFilter = container.dataset.timeFilter || 'day';
    const commentsLimit = container.dataset.commentsLimit;
    const isAuthenticated = {{ 'true' if current_user.is_authenticated else 'false' }};
    const pinnedSubs = {{ pinned_subs | tojson if pinned_subs else '[]' }};
    const feedPinnedSubs = {{ feed_pinned_subs | tojson if feed_pinned_subs else '[]' }};
    const titleLinks = {{ 'true' if title_links else 'false' }};
    let after = container.dataset.after;
    let loading = false;
    let noMorePosts = false;
    let postCount = document.querySelectorAll('.post').length;
    
    const loadingIndicator = document.getElementById('loading-indicator');
    const noMoreIndicator = document.getElementById('no-more-posts');
    
    // Create post HTML from post data
    function createPostHTML(post, index) {
        // Simple HTML escape and newline to br
        const selftextRaw = post.selftext || '';
        const selftext = selftextRaw
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;")
            .replace(/\n/g, "<br>");
            
        const score = post.score.toLocaleString();
        const numComments = post.num_comments.toLocaleString();
        
        let mediaHTML = '';
        
        if (post.is_video && (post.hls_url || post.video_url)) {
            mediaHTML = `
                <div class="post-media video-container" data-hls-url="${post.hls_url || ''}" data-audio-url="${post.audio_url || ''}">
                    <video class="post-video" src="${post.video_url}" loop playsinline autoplay muted></video>
                    ${post.audio_url ? `<audio class="video-audio" src="${post.audio_url}" style="display:none;" loop muted></audio>` : ''}
                    <div class="video-controls">
                        
                        <div class="video-timeline"><div class="video-progress"></div></div>
                        <div class="video-volume-container">
                            <button class="video-btn video-mute" aria-label="Mute">üîá</button>
                            <input type="range" class="video-volume-slider" min="0" max="100" value="0">
                        </div>
                        <div class="video-speed-container">
                            <button class="video-btn video-speed-decrease" aria-label="Decrease speed">‚àí</button>
                            <div class="video-speed-display">1x</div>
                            <button class="video-btn video-speed-increase" aria-label="Increase speed">+</button>
                        </div>
                        <button class="video-btn video-fullscreen" aria-label="Fullscreen">‚õ∂</button>
                    </div>
                </div>`;
        } else if (post.gallery_urls && post.gallery_urls.length > 0) {
            const previewMain = post.gallery_urls[0];
            const previewPeek = post.gallery_urls.length > 1 ? post.gallery_urls[1] : null;
            const galleryItems = post.gallery_urls.map(url => `
                <div class="gallery-item">
                    <img class="gallery-image" src="${url}" alt="Gallery image" loading="lazy">
                </div>
            `).join('');
            mediaHTML = `
                <div class="post-media gallery">
                    <div class="gallery-preview" tabindex="0" role="button" aria-expanded="false">
                        <div class="gallery-preview-main">
                            <img class="gallery-image preview-main" src="${previewMain}" alt="Gallery image" loading="lazy">
                        </div>
                        ${previewPeek ? `
                        <div class="gallery-preview-peek">
                            <img class="gallery-image preview-peek" src="${previewPeek}" alt="Gallery image peek" loading="lazy">
                            ${post.gallery_urls.length > 2 ? `<div class="gallery-more-count">+${post.gallery_urls.length - 1}</div>` : ''}
                        </div>
                        ` : ''}
                    </div>
                    <div class="gallery-scroll gallery-full" hidden>${galleryItems}</div>
                    <!-- navigation buttons removed; preview below main image shows second image -->
                </div>`;
        } else if (post.image_url) {
            mediaHTML = `
                <div class="post-media">
                    <img class="post-image" src="${post.image_url}" alt="Post image">
                </div>`;
        }
        
        const thumbnail = post.thumbnail || post.image_url || '';
        
        return `
            <article class="post" id="post-${index}" data-post-index="${index}" data-thumbnail="${thumbnail}" data-subreddit="${post.subreddit}" data-post-id="${post.id}" data-current-limit="0" data-increment="3" style="cursor: pointer;">
                <div class="post-header">
                    <div class="post-meta-left">
                        <a href="/r/${post.subreddit}" class="subreddit-link-inline trunc">r/${post.subreddit}</a>
                        <span class="meta-text post-author trunc">u/${post.author}</span>
                    </div>
                    <div class="post-meta-actions">
                        <span class="meta-text post-upvotes">‚¨ÜÔ∏è${post.score}</span>
                        ${isAuthenticated && feedPinnedSubs.includes(post.subreddit) ? `
                        <form method="post" action="/unpin/${post.subreddit}" class="inline-form">
                            <input type="hidden" name="csrf_token" value="${window.csrfToken}">
                            <button type="submit" class="meta-action-btn unpin-btn" title="Unpin r/${post.subreddit}">üìç</button>
                        </form>
                        ` : isAuthenticated && !pinnedSubs.includes(post.subreddit) ? `
                        <form method="post" action="/pin/${post.subreddit}" class="inline-form">
                            <input type="hidden" name="csrf_token" value="${window.csrfToken}">
                            <button type="submit" class="meta-action-btn pin-btn" title="Pin r/${post.subreddit}">üìå</button>
                        </form>
                        ` : ''}
                        ${!post.is_self ? `<a href="${post.url}" target="_blank" class="meta-action-btn" title="Open link">üîó</a>` : ''}
                        <a href="/r/${post.subreddit}/comments/${post.id}/share" class="meta-action-btn share-btn" data-share-path="/r/${post.subreddit}/comments/${post.id}/share" title="Share" rel="noopener noreferrer">üîÅ</a>
                        <a href="${post.permalink}" target="_blank" class="meta-action-btn" title="View on Reddit">üì§</a>
                        ${isAuthenticated && post.subreddit !== subreddit ? `
                        <form method="post" action="/ban/${post.subreddit}" class="inline-form" onsubmit="return confirm('Ban r/${post.subreddit}? Posts from this subreddit will be hidden.')">
                            <input type="hidden" name="csrf_token" value="${window.csrfToken}">
                            <button type="submit" class="meta-action-btn ban-btn" title="Ban r/${post.subreddit}">üö´</button>
                        </form>
                        ` : ''}
                    </div>
                    <button class="meta-menu-toggle" aria-haspopup="true" aria-expanded="false" title="Actions">‚ò∞</button>
                    <div class="meta-menu" hidden aria-hidden="true"></div>
                </div>

                <h2 class="post-title">
                        ${titleLinks ? `<a href="/r/${post.subreddit}/comments/${post.id}">${post.title}</a>` : `<span class="post-title-text">${post.title}</span>`}
                </h2>
                
                ${mediaHTML}
                
                ${selftext ? `<div class="post-text-content">${selftext}</div><div class="post-text-toggle" title="Toggle post text" aria-hidden="true"></div>` : ''}
                
                
                <div class="post-top-comments" hidden>
                    <div class="comment-list" data-show-author="false" hidden></div>
                    <div class="load-more-comments-container" hidden style="text-align: center; padding: 10px 0;">
                        <button class="btn load-more-comments-btn">Load 3 more comments</button>
                    </div>
                </div>
            </article>
        `;
    }
    

    // Create comment HTML
    function createCommentHTML(comment, collapsedIds = new Set()) {
        let repliesHTML = '';
        if (comment.replies && comment.replies.length > 0) {
            repliesHTML = `
                <div class="comment-replies">
                    ${comment.replies.map(reply => createCommentHTML(reply, collapsedIds)).join('')}
                </div>
            `;
        }
        
        const isCollapsed = collapsedIds.has(comment.id);
        const collapsedClass = isCollapsed ? 'collapsed' : '';
        const author = comment.author || '[deleted]';
        const authorHTML = author !== '[deleted]'
            ? `<a href="/u/${encodeURIComponent(author)}" class="comment-author">u/${author}</a>`
            : `<span class="comment-author">u/${author}</span>`;
        
        // Use regular comment classes to inherit correct styling (blue border, etc.)
        // Added 'comment-reply' class if it's a child (detected by lack of depth property or handle externally? 
        // We'll mimic the structure of comment_tree.html
        return `
            <div class="comment ${comment.depth > 0 ? 'comment-reply' : ''} ${collapsedClass}" data-depth="${comment.depth || 0}" data-comment-id="${comment.id || ''}">
                <div class="comment-content">
                    <div class="comment-meta-right">
                        ${authorHTML}
                        <span class="comment-score">‚¨ÜÔ∏è ${comment.score.toLocaleString()}</span>
                    </div>
                    <div class="comment-body">${comment.formatted_body || comment.body}</div>
                    ${repliesHTML}
                </div>
            </div>
        `;
    }

    // Load top comments for a post
    async function loadTopComments(postElement, limit = 3) {
        const subreddit = postElement.dataset.subreddit;
        const postId = postElement.dataset.postId;
        
        const commentsContainer = postElement.querySelector('.post-top-comments');
        const listContainer = commentsContainer.querySelector('.comment-list');
        const loadMoreContainer = commentsContainer.querySelector('.load-more-comments-container');
        
        // If just expanding and already loaded, do nothing
        if (limit === 3 && postElement.dataset.commentsLoaded === 'true') {
            return;
        }

        try {
            // Find post ID from link if not in dataset
            let pid = postId;
            if (!pid) {
                const link = postElement.querySelector('.post-title a');
                if (link) {
                    // /r/sub/comments/ID/title
                    const parts = link.getAttribute('href').split('/comments/');
                    if (parts.length > 1) {
                        pid = parts[1].split('/')[0];
                    }
                }
            }
            
            if (!pid) return;
            
            // Capture existing collapsed state before loading new comments
            // We only need top-level collapsed IDs, but recursively is fine too
            const collapsedIds = new Set();
            if (listContainer) {
                listContainer.querySelectorAll('.comment.collapsed').forEach(el => {
                    const id = el.dataset.commentId;
                    if (id) collapsedIds.add(id);
                });
            }

            // Show loading indicator only if first load
            if (limit === 3) {
                listContainer.innerHTML = '<div class="loading-comments"><div class="spinner"></div></div>';
                listContainer.hidden = false;
                commentsContainer.hidden = false;
            } else {
                 // Indicate loading in the button?
                 const btn = loadMoreContainer.querySelector('.load-more-comments-btn');
                 if (btn) btn.textContent = 'Loading...';
            }

            const response = await fetch(`/api/comments?subreddit=${encodeURIComponent(subreddit)}&post_id=${pid}&limit=${limit}`);
            const data = await response.json();
            
            if (data.comments && data.comments.length > 0) {
                listContainer.innerHTML = data.comments.map(c => createCommentHTML(c, collapsedIds)).join('');
                
                // Update load more button
                loadMoreContainer.innerHTML = `
                    <button class="btn btn-secondary btn-small load-more-comments-btn" style="width: 100%;">Load 3 more comments</button>
                `;
                loadMoreContainer.hidden = false;
                
                postElement.dataset.commentsLoaded = 'true';
                postElement.dataset.currentLimit = limit;
            } else {
                listContainer.innerHTML = '<div class="loading-comments">No comments yet.</div>';
            }
        } catch (err) {
            console.error('Error loading comments:', err);
            listContainer.innerHTML = '<div class="loading-comments" style="color: #ff5555;">Failed to load comments</div>';
        }
    }

    // Post click handler for expansion
    container.addEventListener('click', (e) => {
        const post = e.target.closest('.post');
        if (!post) return;
        
        // Ignore clicks on interactive elements and comments
        if (e.target.closest('a, button, video, audio, input, select, .video-controls, .gallery-nav, .search-form, .comment')) {
            return;
        }
        
        const textContent = post.querySelector('.post-text-content');
        const commentsContainer = post.querySelector('.post-top-comments');

        // Check if user clicked on the text content or the dedicated text toggle
        const clickedText = e.target.closest('.post-text-content, .post-text-toggle');

        // If clicked the text area/toggle, toggle text only and do not affect comments
        if (clickedText) {
            if (textContent) {
                textContent.classList.toggle('expanded');
            }
            return;
        }

        // Otherwise, clicking the post (outside the text toggle) follows existing behaviour:
        // toggle comments (and leave text state unchanged)
        let isExpandingComments = true;
        if (commentsContainer && !commentsContainer.hidden) isExpandingComments = false;

        if (commentsContainer) {
            if (isExpandingComments) {
                if (post.dataset.commentsLoaded !== 'true') {
                    loadTopComments(post);
                } else {
                    commentsContainer.hidden = false;
                }
            } else {
                commentsContainer.hidden = true;
            }
        }
    });

    // Initialize video controls for newly added posts
    function initVideoControls(container) {
        // Trigger DOMContentLoaded-like initialization for new videos
        const event = new CustomEvent('newPostsAdded', { detail: { container } });
        document.dispatchEvent(event);
    }
    
    async function loadMorePosts() {
        if (loading || noMorePosts || !after) return;
        
        loading = true;
        loadingIndicator.style.display = 'block';
        
        try {
            const response = await fetch(`/api/posts?subreddit=${encodeURIComponent(subreddit)}&sort=${encodeURIComponent(sort)}&t=${encodeURIComponent(timeFilter)}&after=${encodeURIComponent(after)}`);
            const data = await response.json();
            
            if (data.posts && data.posts.length > 0) {
                data.posts.forEach(post => {
                    postCount++;
                    const postHTML = createPostHTML(post, postCount);
                    container.insertAdjacentHTML('beforeend', postHTML);
                    
                    // Add to mini-nav
                    addToMiniNav(post, postCount);
                });
                
                after = data.after;
                container.dataset.after = after || '';
                
                if (!after) {
                    noMorePosts = true;
                    noMoreIndicator.style.display = 'block';
                }
                
                // Re-initialize video controls for new posts
                initVideoControls(container);
                setupTriggerObserver();
            } else {
                noMorePosts = true;
                noMoreIndicator.style.display = 'block';
            }
        } catch (err) {
            console.error('Error loading more posts:', err);
        } finally {
            loading = false;
            loadingIndicator.style.display = 'none';
        }
    }
    
    // Observer for triggering load at post 20 (or 5 posts before end)
    function setupTriggerObserver() {
        const posts = document.querySelectorAll('.post');
        const triggerIndex = Math.max(posts.length - 5, 20);
        const triggerPost = posts[triggerIndex - 1];
        
        if (!triggerPost || triggerPost.dataset.observed) return;
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    loadMorePosts();
                    observer.disconnect();
                }
            });
        }, { threshold: 0.1 });
        
        triggerPost.dataset.observed = 'true';
        observer.observe(triggerPost);
    }
    
    // Add post to mini-nav
    function addToMiniNav(post, index) {
        const miniNavItems = document.getElementById('mini-nav-items');
        if (!miniNavItems) return;
        
        const thumbnail = post.thumbnail || post.image_url || '';
        const isValidThumb = thumbnail && thumbnail.startsWith('http');
        
        let content;
        if (isValidThumb) {
            content = `<img src="${thumbnail}" alt="" class="mini-nav-thumb">`;
        } else if (post.is_self) {
            content = `<div class="mini-nav-placeholder">üìù</div>`;
        } else {
            content = `<div class="mini-nav-placeholder">üîó</div>`;
        }
        
        const item = document.createElement('a');
        item.href = `#post-${index}`;
        item.className = 'mini-nav-item';
        item.dataset.postIndex = index;
        item.title = post.title;
        item.innerHTML = content;
        miniNavItems.appendChild(item);
    }
    
    // Handle load more comments button click
    container.addEventListener('click', (e) => {
        if (e.target.matches('.load-more-comments-btn')) {
            e.stopPropagation(); // Prevent post expansion logic
            const post = e.target.closest('.post');
            if (post) {
                const currentLimit = parseInt(post.dataset.currentLimit || 3);
                const newLimit = currentLimit + 3;
                loadTopComments(post, newLimit);
            }
        }
    });
    
    // Initial setup
    if (after) {
        setupTriggerObserver();
    }
    
    // Mini-nav minimap functionality (like VS Code)
    const miniNav = document.getElementById('mini-nav');
    const miniNavItems = document.getElementById('mini-nav-items');
    const miniNavViewport = document.getElementById('mini-nav-viewport');
    
    if (miniNav && miniNavItems && miniNavViewport) {
        let isDraggingViewport = false;
        let dragStartY = 0;
        let dragStartScroll = 0;
        
        // Update viewport indicator position and size
        function updateViewportIndicator() {
            const maxPageScroll = document.documentElement.scrollHeight - window.innerHeight;
            const currentPageScroll = window.pageYOffset || document.documentElement.scrollTop;
            const scrollRatio = maxPageScroll > 0 ? currentPageScroll / maxPageScroll : 0;
            
            // Sync mini-nav items scroll
            const maxNavScroll = miniNavItems.scrollHeight - miniNavItems.clientHeight;
            miniNavItems.scrollTop = scrollRatio * maxNavScroll;
            
            // Calculate viewport indicator size and position
            const viewportHeight = window.innerHeight;
            const totalHeight = document.documentElement.scrollHeight;
            const miniNavRect = miniNav.getBoundingClientRect();
            const itemsRect = miniNavItems.getBoundingClientRect();
            const itemsTopOffset = Math.max(0, itemsRect.top - miniNavRect.top);
            const itemsHeight = Math.max(0, itemsRect.height);
            
            const viewportRatio = viewportHeight / totalHeight;
            const indicatorHeight = Math.max(30, itemsHeight * viewportRatio);
            const indicatorTop = itemsTopOffset + scrollRatio * (itemsHeight - indicatorHeight);
            
            miniNavViewport.style.height = indicatorHeight + 'px';
            miniNavViewport.style.top = indicatorTop + 'px';
            
            // Update active post highlighting
            const posts = document.querySelectorAll('.post');
            const viewportCenter = window.innerHeight / 2;
            let closestPost = null;
            let closestDistance = Infinity;
            
            posts.forEach(post => {
                const rect = post.getBoundingClientRect();
                const postCenter = rect.top + rect.height / 2;
                const distance = Math.abs(postCenter - viewportCenter);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPost = post;
                }
            });
            
            if (closestPost) {
                const index = closestPost.dataset.postIndex;
                const navItem = miniNav.querySelector(`[data-post-index="${index}"]`);
                if (navItem) {
                    miniNav.querySelectorAll('.mini-nav-item').forEach(i => i.classList.remove('active'));
                    navItem.classList.add('active');
                }
            }
        }
        
        // Click on minimap to jump to position
        miniNav.addEventListener('mousedown', (e) => {
            if (e.target === miniNavViewport || miniNavViewport.contains(e.target)) {
                // Start dragging viewport
                isDraggingViewport = true;
                dragStartY = e.clientY;
                dragStartScroll = window.pageYOffset || document.documentElement.scrollTop;
                e.preventDefault();
            } else if (e.target === miniNav || e.target === miniNavItems || miniNavItems.contains(e.target)) {
                // Click to jump
                const rect = miniNavItems.getBoundingClientRect();
                const clickRatio = (e.clientY - rect.top) / rect.height;
                const maxPageScroll = document.documentElement.scrollHeight - window.innerHeight;
                const targetScroll = clickRatio * maxPageScroll;
                window.scrollTo(0, targetScroll);
                e.preventDefault();
            }
        });
        
        // Drag viewport to scroll
        document.addEventListener('mousemove', (e) => {
            if (isDraggingViewport) {
                const deltaY = e.clientY - dragStartY;
                const miniNavHeight = miniNavItems.clientHeight;
                const maxPageScroll = document.documentElement.scrollHeight - window.innerHeight;
                const scrollDelta = (deltaY / miniNavHeight) * maxPageScroll;
                window.scrollTo(0, dragStartScroll + scrollDelta);
                e.preventDefault();
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDraggingViewport = false;
        });
        
        window.addEventListener('scroll', updateViewportIndicator, { passive: true });
        window.addEventListener('resize', updateViewportIndicator, { passive: true });

        const postsContainer = document.getElementById('posts-container');
        if (window.ResizeObserver && postsContainer) {
            const resizeObserver = new ResizeObserver(() => {
                updateViewportIndicator();
            });
            resizeObserver.observe(postsContainer);
        }
        
        // Adjust sidebar position based on header visibility
        function updateNavPosition() {
            const header = document.querySelector('.header');
            if (header) {
                const isHidden = header.classList.contains('header-hidden');
                miniNav.style.setProperty('--nav-top', isHidden ? '20px' : '70px');
                // Update viewport indicator when header position changes
                setTimeout(updateViewportIndicator, 350);
            }
        }
        
        // Watch for header class changes
        const header = document.querySelector('.header');
        if (header) {
            const observer = new MutationObserver(updateNavPosition);
            observer.observe(header, { attributes: true, attributeFilter: ['class'] });
            updateNavPosition();
        }
        
        // Initial update
        updateViewportIndicator();
    }

    // Meta-action condensed menu for narrow screens
    document.addEventListener('click', (e) => {
        const toggle = e.target.closest('.meta-menu-toggle');
        if (toggle) {
            e.stopPropagation();
            const post = toggle.closest('.post');
            if (!post) return;
            const menu = post.querySelector('.meta-menu');
            const actions = post.querySelector('.post-meta-actions');
            if (!menu || !actions) return;
            if (menu.hidden) {
                // populate and show
                // Clone actions into the menu, then append readable labels from title attributes
                menu.innerHTML = actions.innerHTML;
                // Remove non-interactive upvotes from the dropdown menu (keep them visible in header)
                menu.querySelectorAll('.post-upvotes').forEach(n => n.remove());
                // For each action (button/link/form) append a text label using the title/aria-label
                menu.querySelectorAll('.meta-action-btn, form.inline-form').forEach(node => {
                    if (node.tagName === 'FORM') {
                        const btn = node.querySelector('button');
                        if (btn) {
                            // Prefer a short static label for pin/ban actions to avoid showing subreddit name
                            let labelText = '';
                            if (btn.classList.contains('pin-btn')) labelText = 'Pin';
                            else if (btn.classList.contains('unpin-btn')) labelText = 'Unpin';
                            else if (btn.classList.contains('ban-btn')) labelText = 'Ban';
                            else labelText = (btn.getAttribute('title') || btn.getAttribute('aria-label') || btn.textContent || '').replace(/\s*r\//, '').replace(/\(.+\)/, '').trim();

                            if (!btn.querySelector('.meta-action-label')) {
                                const span = document.createElement('span');
                                span.className = 'meta-action-label';
                                span.textContent = labelText ? (' ' + labelText) : '';
                                btn.appendChild(span);
                            }
                        }
                    } else {
                        // node is a link/button element
                        // for certain button classes prefer short labels
                        let labelText = '';
                        if (node.classList && node.classList.contains('pin-btn')) labelText = 'Pin';
                        else if (node.classList && node.classList.contains('unpin-btn')) labelText = 'Unpin';
                        else if (node.classList && node.classList.contains('ban-btn')) labelText = 'Ban';
                        else labelText = (node.getAttribute('title') || node.getAttribute('aria-label') || node.textContent || '').replace(/\s*r\//, '').replace(/\(.+\)/, '').trim();

                        if (!node.querySelector || !node.querySelector('.meta-action-label')) {
                            const span = document.createElement('span');
                            span.className = 'meta-action-label';
                            span.textContent = labelText ? (' ' + labelText) : '';
                            node.appendChild(span);
                        }
                    }
                });

                menu.hidden = false;
                menu.setAttribute('aria-hidden', 'false');
                toggle.setAttribute('aria-expanded', 'true');
                // attach share handlers and other dynamic handlers
                setupShareButtons(menu);

                // Position menu under the toggle button (relative to the post)
                menu.style.right = 'auto';
                const toggleRect = toggle.getBoundingClientRect();
                const postRect = post.getBoundingClientRect();
                let left = toggleRect.left - postRect.left;
                let top = toggleRect.bottom - postRect.top;

                // apply initial position
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';

                // adjust to avoid overflow to the right
                const menuRect = menu.getBoundingClientRect();
                const overflowRight = (menuRect.right - postRect.right);
                if (overflowRight > 0) {
                    left = left - overflowRight - 8;
                    menu.style.left = Math.max(8, left) + 'px';
                }

                // ensure menu doesn't go off the left edge
                const updatedMenuRect = menu.getBoundingClientRect();
                if (updatedMenuRect.left < postRect.left + 8) {
                    menu.style.left = '8px';
                }

            } else {
                menu.hidden = true;
                menu.setAttribute('aria-hidden', 'true');
                toggle.setAttribute('aria-expanded', 'false');
                menu.style.left = '';
                menu.style.top = '';
                menu.style.right = '';
            }
            return;
        }

        // Close any open meta menus when clicking outside
        document.querySelectorAll('.meta-menu').forEach(m => {
            if (!m.hidden) {
                m.hidden = true;
                m.setAttribute('aria-hidden', 'true');
                const t = m.closest('.post') ? m.closest('.post').querySelector('.meta-menu-toggle') : null;
                if (t) t.setAttribute('aria-expanded', 'false');
            }
        });
    }, true);

    // Hide menus on resize to avoid stale state
    window.addEventListener('resize', () => {
        if (window.innerWidth > 480) {
            document.querySelectorAll('.meta-menu').forEach(m => { m.hidden = true; m.setAttribute('aria-hidden','true'); });
            document.querySelectorAll('.meta-menu-toggle').forEach(t => t.setAttribute('aria-expanded','false'));
        }
    });
})();
</script>
{% endblock %}
